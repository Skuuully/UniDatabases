-- Drop all the tables first since they currently exist, cascade
-- to remove the views too

DROP TABLE CLIENTS, CONTACTS, CONTACT_DETAILS, ESTIMATES, REJECTS,
WORK_ORDERS, INVOICES, LOGS, OUTDATED_LOGS, EMPLOYEES, EMPLOYEE_PHONES, CONFIG CASCADE;

DROP SEQUENCE CLIENTS_SEQUENCE, CONTACTS_SEQUENCE, DETAILS_SEQUENCE, ESTIMATES_SEQUENCE,
REJECTS_SEQUENCE, WORK_ORDERS_SEQUENCE, INVOICES_SEQUENCE, LOGS_SEQUENCE,
OUTDATED_LOGS_SEQUENCE, EMPLOYEES_SEQUENCE;

--Using ints for all ID's as should use less memory than numeric(n, 0)
-- will not need to be floating point anyway
CREATE TABLE CLIENTS(
CLIENTID INT NOT NULL,
COMPANY_NAME VARCHAR(40) NOT NULL,
BILLING_ADDRESS VARCHAR(80) NOT NULL,
PRIMARY KEY (CLIENTID)
);

CREATE TABLE CONTACTS(
CONTACTID INT NOT NULL,
CLIENTID INT NOT NULL,
NAME VARCHAR(30) NOT NULL,
NOTES TEXT,
PRIMARY KEY (CONTACTID),
FOREIGN KEY (CLIENTID) REFERENCES CLIENTS(CLIENTID)
);

CREATE TABLE CONTACT_DETAILS(
DETAILID INT NOT NULL,
CONTACTID INT NOT NULL,
PHONE_NUMBER NUMERIC (11, 0),
EMAIL VARCHAR(40),
FAX VARCHAR(40),
PRIMARY KEY (DETAILID),
FOREIGN KEY (CONTACTID) REFERENCES CONTACTS(CONTACTID),
-- Check is to make sure at least one of the 3 has been entered
-- Otherwise it is a pointless row in the table
CHECK (PHONE_NUMBER != NULL AND EMAIL != NULL AND FAX != NULL)
);

CREATE TABLE ESTIMATES(
ESTIMATEID INT NOT NULL,
CLIENTID INT NOT NULL,
-- Must be issued on the day
DATE_ISSUED TIMESTAMP NOT NULL CHECK(DATE_ISSUED = CURRENT_DATE),
DESCRIPTION TEXT,
RATE NUMERIC(10, 0) NOT NULL CHECK(RATE > 0),
CONDITIONS TEXT,
-- If boolean is true become work order
-- else become reject
APPROVAL_STATUS BOOLEAN,
PRIMARY KEY (ESTIMATEID),
FOREIGN KEY (CLIENTID) REFERENCES CLIENTS(CLIENTID)
);

CREATE TABLE REJECTS(
REJECTID INT NOT NULL,
ESTIMATEID INT NOT NULL,
PRIMARY KEY (REJECTID),
FOREIGN KEY (ESTIMATEID) REFERENCES ESTIMATES(ESTIMATEID)
);

CREATE TABLE WORK_ORDERS(
WORK_ORDERID INT NOT NULL,
ESTIMATEID INT NOT NULL,
-- A work order must be added on the day it was made
DATE_APPROVED TIMESTAMP NOT NULL CHECK(DATE_APPROVED = CURRENT_DATE),
NOTES TEXT,
PRIMARY KEY (WORK_ORDERID),
FOREIGN KEY (ESTIMATEID) REFERENCES ESTIMATES(ESTIMATEID)
);

CREATE TABLE INVOICES(
INVOICEID INT NOT NULL,
WORK_ORDERID INT NOT NULL,
CLIENTID INT NOT NULL,
TERMS TEXT,
INVOICE_DATE TIMESTAMP NOT NULL,
SUBTOTAL NUMERIC(10, 0) NOT NULL CHECK (SUBTOTAL > 0),
PRIMARY KEY (INVOICEID),
FOREIGN KEY (WORK_ORDERID) REFERENCES WORK_ORDERS(WORK_ORDERID),
FOREIGN KEY (CLIENTID) REFERENCES CLIENTS(CLIENTID)
);

CREATE TABLE EMPLOYEES(
EMPLOYEEID INT NOT NULL,
NAME VARCHAR(40),
PAY_RATE NUMERIC(10, 0) CHECK (PAY_RATE > 0),
BILL_RATE NUMERIC(10, 0) CHECK (BILL_RATE > 0),
ADDRESS VARCHAR(40),
PRIMARY KEY (EMPLOYEEID)
);

CREATE TABLE LOGS(
LOGID INT NOT NULL,
WORK_ORDERID INT NOT NULL,
EMPLOYEEID INT NOT NULL,
WORK_DONE TEXT NOT NULL,
-- Time spent per log entry should be less than 5hours
-- Ideally logs are updated every ~1hour
HOURS_WORKED NUMERIC(10, 2) NOT NULL CHECK(HOURS_WORKED > 0 AND HOURS_WORKED <= 5),
-- Date worked should not be in the future or in the past
-- Updated on the day it was done
DATE_WORKED TIMESTAMP NOT NULL CHECK(DATE_WORKED = CURRENT_DATE),
PRIMARY KEY (LOGID),
FOREIGN KEY (WORK_ORDERID) REFERENCES WORK_ORDERS(WORK_ORDERID),
FOREIGN KEY (EMPLOYEEID) REFERENCES EMPLOYEES(EMPLOYEEID)
);

-- Assumption: 2 different employees may not have the same number
CREATE TABLE EMPLOYEE_PHONES(
PHONE_NUMBER INT NOT NULL,
EMPLOYEEID INT NOT NULL,
PRIMARY KEY (PHONE_NUMBER),
FOREIGN KEY (EMPLOYEEID) REFERENCES EMPLOYEES(EMPLOYEEID)
);

CREATE TABLE OUTDATED_LOGS(
OUTDATEDID INT NOT NULL,
LOGID INT NOT NULL,
WORK_DONE TEXT,
PRIMARY KEY (OUTDATEDID),
FOREIGN KEY (LOGID) REFERENCES LOGS(LOGID)
);

CREATE TABLE CONFIG(
COMPANY_NAME VARCHAR(40) NOT NULL,
-- VAT_RATE = 100 means 100% extra onto price
-- so 20 would be 20% extra
VAT_RATE NUMERIC(5, 2) NOT NULL CHECK(VAT_RATE > 0),
PRIMARY KEY (COMPANY_NAME)
);

-- View to include the companies name and id with some invoice details
CREATE VIEW SALES AS
	SELECT INVOICEID, INVOICE_DATE, SUBTOTAL, SUBTOTAL * (VAT_RATE / 100) AS VAT,
	SUBTOTAL + (SUBTOTAL * (VAT_RATE / 100)) AS TOTAL, CLIENTS.COMPANY_NAME, CLIENTS.CLIENTID
	FROM INVOICES, CLIENTS, CONFIG
	WHERE INVOICES.CLIENTID = CLIENTS.CLIENTID
	ORDER BY INVOICEID;
	
-- Some employee data based on an employee such as how much to pay
CREATE VIEW EMPLOYEE AS
	SELECT NAME, DATE_WORKED, WORK_ORDERID, PAY_RATE, HOURS_WORKED, HOURS_WORKED * PAY_RATE AS TOTAL
	FROM EMPLOYEES, LOGS
	WHERE EMPLOYEES.EMPLOYEEID = LOGS.EMPLOYEEID;

-- If the status on an estimate changes push into 
-- either the rejects or work orders depending on value
CREATE OR REPLACE FUNCTION CHANGE_STATUS()
RETURNS TRIGGER AS
$BODY$
BEGIN
	IF NEW.APPROVAL_STATUS = TRUE THEN
		INSERT INTO WORK_ORDERS(WORK_ORDERID, ESTIMATEID, DATE_APPROVED)
		VALUES(NEXTVAL('WORK_ORDERS_SEQUENCE'), NEW.ESTIMATEID, CURRENT_DATE);
	ELSE 
		IF NEW.APPROVAL_STATUS = FALSE THEN
			INSERT INTO REJECTS(REJECTID, ESTIMATEID)
			VALUES(NEXTVAL('REJECTS_SEQUENCE'), NEW.ESTIMATEID);
		END IF;
	END IF;
	RETURN NEW;
END;
$BODY$
LANGUAGE plpgsql;
	
-- Trigger for update on an estimate
CREATE TRIGGER 	UPDATE_ACCEPT_DECLINE
	AFTER UPDATE ON ESTIMATES
	FOR EACH ROW
	WHEN (OLD.APPROVAL_STATUS IS DISTINCT FROM NEW.APPROVAL_STATUS)
	EXECUTE PROCEDURE CHANGE_STATUS();
	
-- Trigger for insert on an estimate incase the estimate wants to go
-- straight to a work order/reject
CREATE TRIGGER INSERT_ACCEPT_DECLINE
	AFTER INSERT ON ESTIMATES
	FOR EACH ROW
	EXECUTE PROCEDURE CHANGE_STATUS();
	
-- Function to push data into outdated logs
CREATE OR REPLACE FUNCTION UPDATE_OUTDATED()
RETURNS TRIGGER AS
$BODY$
BEGIN
	INSERT INTO
	OUTDATED_LOGS(OUTDATEDID, LOGID, WORK_DONE)
	VALUES(NEXTVAL('OUTDATED_LOGS_SEQUENCE'), OLD.LOGID , OLD.WORK_DONE);
	RETURN NEW;
END;
$BODY$
LANGUAGE plpgsql;

-- Trigger for update on logs to push into outdated if changed
CREATE TRIGGER LOG_UPDATE
    AFTER UPDATE ON LOGS
    FOR EACH ROW
    WHEN (OLD.WORK_DONE IS DISTINCT FROM NEW.WORK_DONE)
    EXECUTE PROCEDURE UPDATE_OUTDATED();
	
-- If log deleted push into outdated logs
CREATE TRIGGER LOG_DELETE
    BEFORE DELETE ON LOGS
    FOR EACH ROW
    EXECUTE PROCEDURE UPDATE_OUTDATED();
	
-- Sequences to increase the primary key by 1
CREATE SEQUENCE CLIENTS_SEQUENCE
START 1
INCREMENT 1;

CREATE SEQUENCE CONTACTS_SEQUENCE
START 1
INCREMENT 1;

CREATE SEQUENCE DETAILS_SEQUENCE
START 1
INCREMENT 1;

CREATE SEQUENCE ESTIMATES_SEQUENCE
START 1
INCREMENT 1;

CREATE SEQUENCE REJECTS_SEQUENCE
START 1
INCREMENT 1;

CREATE SEQUENCE WORK_ORDERS_SEQUENCE
START 1
INCREMENT 1;

CREATE SEQUENCE INVOICES_SEQUENCE
START 1
INCREMENT 1;

CREATE SEQUENCE EMPLOYEES_SEQUENCE
START 1
INCREMENT 1;

CREATE SEQUENCE LOGS_SEQUENCE
START 1
INCREMENT 1;

CREATE SEQUENCE OUTDATED_LOGS_SEQUENCE
START 1
INCREMENT 1;

-- Populating the tables/testing
--INSERT INTO CLIENTS
--VALUES(NEXTVAL('CLIENTS_SEQUENCE'), 'HH', '140000B ROAD');
--INSERT INTO CLIENTS
--VALUES(NEXTVAL('CLIENTS_SEQUENCE'), 'HALL', '150000B ROAD');
--INSERT INTO CLIENTS
--VALUES(NEXTVAL('CLIENTS_SEQUENCE'), 'JC', '160000B ROAD');
--INSERT INTO CLIENTS
--VALUES(NEXTVAL('CLIENTS_SEQUENCE'), 'VAN', '170000B ROAD');

--INSERT INTO CONFIG
--VALUES('SKULL', '20');

--INSERT INTO CONTACTS
--VALUES(NEXTVAL('CONTACTS_SEQUENCE'), '2', 'BILL');

--INSERT INTO ESTIMATES
--VALUES(NEXTVAL('ESTIMATES_SEQUENCE'), '2', CURRENT_DATE, 'NOTEY BOI', '8', 'SOME KINDA CONDITION', TRUE);

--INSERT INTO EMPLOYEES
--VALUES(NEXTVAL('EMPLOYEES_SEQUENCE'), 'BILL', '10', '12', '120 FUCKBOI AVENUE');

--INSERT INTO WORK_ORDERS
--VALUES(NEXTVAL('WORK_ORDERS_SEQUENCE'), '1', CURRENT_DATE, 'BLEH');

--INSERT INTO LOGS
--VALUES (NEXTVAL('LOGS_SEQUENCE'), '1', '1', 'NONE','3', CURRENT_DATE);

--INSERT INTO LOGS
--VALUES (NEXTVAL('LOGS_SEQUENCE'), '1', '1', 'REEEEEEE','3', CURRENT_DATE);

--UPDATE LOGS
--SET WORK_DONE = 'BLUE'
--WHERE LOGID = '1';

--DELETE FROM LOGS
--WHERE WORK_DONE = 'REEEEEEE';

